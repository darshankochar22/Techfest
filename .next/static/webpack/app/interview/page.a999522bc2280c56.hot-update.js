"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/interview/page",{

/***/ "(app-pages-browser)/./hooks/useInterviewSession.ts":
/*!**************************************!*\
  !*** ./hooks/useInterviewSession.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useInterviewSession: () => (/* binding */ useInterviewSession)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ useInterviewSession auto */ var _process_env_NEXT_PUBLIC_INTERVIEW_API;\n\nconst baseUrl = ((_process_env_NEXT_PUBLIC_INTERVIEW_API = process.env.NEXT_PUBLIC_INTERVIEW_API) === null || _process_env_NEXT_PUBLIC_INTERVIEW_API === void 0 ? void 0 : _process_env_NEXT_PUBLIC_INTERVIEW_API.replace(/\\/$/, \"\")) || \"http://localhost:8000\";\nconst b64ToBlob = (b64, type)=>{\n    const byteCharacters = atob(b64);\n    const byteNumbers = new Array(byteCharacters.length);\n    for(let i = 0; i < byteCharacters.length; i++){\n        byteNumbers[i] = byteCharacters.charCodeAt(i);\n    }\n    const byteArray = new Uint8Array(byteNumbers);\n    return new Blob([\n        byteArray\n    ], {\n        type\n    });\n};\nfunction useInterviewSession() {\n    const [sessionId, setSessionId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useInterviewSession.useState\": ()=>crypto.randomUUID()\n    }[\"useInterviewSession.useState\"]);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"idle\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isRecording, setIsRecording] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [replyAudioUrl, setReplyAudioUrl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isSavingContext, setIsSavingContext] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [contextError, setContextError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [contextSavedAt, setContextSavedAt] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const recorderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const chunkRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useInterviewSession.useEffect\": ()=>({\n                \"useInterviewSession.useEffect\": ()=>{\n                    if (recorderRef.current && recorderRef.current.state !== \"inactive\") {\n                        recorderRef.current.stop();\n                    }\n                    if (replyAudioUrl) {\n                        URL.revokeObjectURL(replyAudioUrl);\n                    }\n                }\n            })[\"useInterviewSession.useEffect\"]\n    }[\"useInterviewSession.useEffect\"], [\n        replyAudioUrl\n    ]);\n    const playReplyAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useInterviewSession.useCallback[playReplyAudio]\": (base64Audio)=>{\n            if (!base64Audio) return;\n            const blob = b64ToBlob(base64Audio, \"audio/wav\");\n            const url = URL.createObjectURL(blob);\n            setReplyAudioUrl({\n                \"useInterviewSession.useCallback[playReplyAudio]\": (prev)=>{\n                    if (prev) URL.revokeObjectURL(prev);\n                    return url;\n                }\n            }[\"useInterviewSession.useCallback[playReplyAudio]\"]);\n            const player = new Audio(url);\n            player.play().catch({\n                \"useInterviewSession.useCallback[playReplyAudio]\": (err)=>{\n                    console.error(\"Failed to play reply audio:\", err);\n                }\n            }[\"useInterviewSession.useCallback[playReplyAudio]\"]);\n        }\n    }[\"useInterviewSession.useCallback[playReplyAudio]\"], []);\n    const sendTurn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useInterviewSession.useCallback[sendTurn]\": async (audioBlob)=>{\n            setStatus(\"processing\");\n            setError(null);\n            try {\n                var _payload_transcript, _payload_replyText;\n                const file = new File([\n                    audioBlob\n                ], \"turn-\".concat(Date.now(), \".webm\"), {\n                    type: audioBlob.type\n                });\n                const form = new FormData();\n                form.append(\"session_id\", sessionId);\n                form.append(\"audio\", file);\n                const response = await fetch(\"\".concat(baseUrl, \"/interview/turn\"), {\n                    method: \"POST\",\n                    body: form\n                });\n                if (!response.ok) {\n                    throw new Error(\"Backend error (\".concat(response.status, \")\"));\n                }\n                const payload = await response.json();\n                const transcript = (_payload_transcript = payload.transcript) === null || _payload_transcript === void 0 ? void 0 : _payload_transcript.trim();\n                const reply = (_payload_replyText = payload.replyText) === null || _payload_replyText === void 0 ? void 0 : _payload_replyText.trim();\n                setMessages({\n                    \"useInterviewSession.useCallback[sendTurn]\": (prev)=>[\n                            ...prev,\n                            transcript ? {\n                                id: \"\".concat(Date.now(), \"-user\"),\n                                speaker: \"user\",\n                                text: transcript,\n                                timestamp: Date.now()\n                            } : null,\n                            reply ? {\n                                id: \"\".concat(Date.now(), \"-assistant\"),\n                                speaker: \"assistant\",\n                                text: reply,\n                                timestamp: Date.now()\n                            } : null\n                        ].filter(Boolean)\n                }[\"useInterviewSession.useCallback[sendTurn]\"]);\n                if (payload.replyAudio) {\n                    playReplyAudio(payload.replyAudio);\n                }\n                setStatus(\"idle\");\n            } catch (err) {\n                console.error(err);\n                setError(err instanceof Error ? err.message : \"Unknown error\");\n                setStatus(\"error\");\n            }\n        }\n    }[\"useInterviewSession.useCallback[sendTurn]\"], [\n        sessionId,\n        playReplyAudio\n    ]);\n    const startRecording = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useInterviewSession.useCallback[startRecording]\": async ()=>{\n            if (false) {}\n            if (isRecording) return;\n            setError(null);\n            try {\n                const stream = await navigator.mediaDevices.getUserMedia({\n                    audio: true\n                });\n                const mimeType = MediaRecorder.isTypeSupported(\"audio/webm;codecs=opus\") ? \"audio/webm;codecs=opus\" : undefined;\n                const recorder = new MediaRecorder(stream, mimeType ? {\n                    mimeType\n                } : undefined);\n                recorderRef.current = recorder;\n                chunkRef.current = [];\n                recorder.ondataavailable = ({\n                    \"useInterviewSession.useCallback[startRecording]\": (event)=>{\n                        if (event.data && event.data.size > 0) {\n                            chunkRef.current.push(event.data);\n                        }\n                    }\n                })[\"useInterviewSession.useCallback[startRecording]\"];\n                recorder.onstop = ({\n                    \"useInterviewSession.useCallback[startRecording]\": async ()=>{\n                        stream.getTracks().forEach({\n                            \"useInterviewSession.useCallback[startRecording]\": (track)=>track.stop()\n                        }[\"useInterviewSession.useCallback[startRecording]\"]);\n                        const audioBlob = new Blob(chunkRef.current, {\n                            type: mimeType || \"audio/webm\"\n                        });\n                        chunkRef.current = [];\n                        setIsRecording(false);\n                        if (audioBlob.size > 0) {\n                            await sendTurn(audioBlob);\n                        } else {\n                            setStatus(\"idle\");\n                        }\n                    }\n                })[\"useInterviewSession.useCallback[startRecording]\"];\n                recorder.start();\n                setIsRecording(true);\n                setStatus(\"recording\");\n            } catch (err) {\n                console.error(err);\n                setError(\"Unable to access microphone\");\n                setStatus(\"error\");\n            }\n        }\n    }[\"useInterviewSession.useCallback[startRecording]\"], [\n        isRecording,\n        sendTurn\n    ]);\n    const stopRecording = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useInterviewSession.useCallback[stopRecording]\": ()=>{\n            if (recorderRef.current && recorderRef.current.state === \"recording\") {\n                recorderRef.current.stop();\n            }\n        }\n    }[\"useInterviewSession.useCallback[stopRecording]\"], []);\n    const resetSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useInterviewSession.useCallback[resetSession]\": async ()=>{\n            try {\n                await fetch(\"\".concat(baseUrl, \"/interview/reset\"), {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        session_id: sessionId\n                    })\n                });\n            } catch (err) {\n                console.warn(\"Failed to reset server session\", err);\n            } finally{\n                setSessionId(crypto.randomUUID());\n                setMessages([]);\n                setError(null);\n                setStatus(\"idle\");\n                setContextSavedAt(null);\n                setContextError(null);\n            }\n        }\n    }[\"useInterviewSession.useCallback[resetSession]\"], [\n        sessionId\n    ]);\n    const updateContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useInterviewSession.useCallback[updateContext]\": async (param)=>{\n            let { resumeText, jobDescription } = param;\n            setIsSavingContext(true);\n            setContextError(null);\n            try {\n                const response = await fetch(\"\".concat(baseUrl, \"/interview/context\"), {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        session_id: sessionId,\n                        resume_text: resumeText,\n                        job_description: jobDescription\n                    })\n                });\n                if (!response.ok) {\n                    throw new Error(\"Backend error (\".concat(response.status, \")\"));\n                }\n                setContextSavedAt(Date.now());\n                setMessages([]) // Clear local transcript to reflect the refreshed context\n                ;\n            } catch (err) {\n                console.error(err);\n                setContextError(err instanceof Error ? err.message : \"Unable to save context\");\n            } finally{\n                setIsSavingContext(false);\n            }\n        }\n    }[\"useInterviewSession.useCallback[updateContext]\"], [\n        sessionId\n    ]);\n    return {\n        sessionId,\n        messages,\n        status,\n        error,\n        isRecording,\n        startRecording,\n        stopRecording,\n        resetSession,\n        updateContext,\n        isSavingContext,\n        contextError,\n        contextSavedAt,\n        backendUrl: baseUrl\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUludGVydmlld1Nlc3Npb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs2RUFnQkVBO0FBZHVFO0FBYXpFLE1BQU1LLFVBQ0pMLEVBQUFBLHlDQUFBQSxPQUFPQSxDQUFDTSxHQUFHLENBQUNDLHlCQUF5QixjQUFyQ1AsNkRBQUFBLHVDQUF1Q1EsT0FBTyxDQUFDLE9BQU8sUUFBTztBQUUvRCxNQUFNQyxZQUFZLENBQUNDLEtBQWFDO0lBQzlCLE1BQU1DLGlCQUFpQkMsS0FBS0g7SUFDNUIsTUFBTUksY0FBYyxJQUFJQyxNQUFNSCxlQUFlSSxNQUFNO0lBQ25ELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxlQUFlSSxNQUFNLEVBQUVDLElBQUs7UUFDOUNILFdBQVcsQ0FBQ0csRUFBRSxHQUFHTCxlQUFlTSxVQUFVLENBQUNEO0lBQzdDO0lBQ0EsTUFBTUUsWUFBWSxJQUFJQyxXQUFXTjtJQUNqQyxPQUFPLElBQUlPLEtBQUs7UUFBQ0Y7S0FBVSxFQUFFO1FBQUVSO0lBQUs7QUFDdEM7QUFFTyxTQUFTVztJQUNkLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHcEIsK0NBQVFBO3dDQUFDLElBQU1xQixPQUFPQyxVQUFVOztJQUNsRSxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR3hCLCtDQUFRQSxDQUFxQixFQUFFO0lBQy9ELE1BQU0sQ0FBQ3lCLFFBQVFDLFVBQVUsR0FBRzFCLCtDQUFRQSxDQUFTO0lBQzdDLE1BQU0sQ0FBQzJCLE9BQU9DLFNBQVMsR0FBRzVCLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUM2QixhQUFhQyxlQUFlLEdBQUc5QiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUMrQixlQUFlQyxpQkFBaUIsR0FBR2hDLCtDQUFRQSxDQUFnQjtJQUNsRSxNQUFNLENBQUNpQyxpQkFBaUJDLG1CQUFtQixHQUFHbEMsK0NBQVFBLENBQUM7SUFDdkQsTUFBTSxDQUFDbUMsY0FBY0MsZ0JB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QUFJLENBQUNqRCxTQUFTSSxFQUFFLEVBQUU7b0JBQ2hCLE1BQU0sSUFBSUMsTUFBTSxrQkFBa0MsT0FBaEJMLFNBQVMzQyxNQUFNLEVBQUM7Z0JBQ3BEO2dCQUVBYSxrQkFBa0J5QixLQUFLQyxHQUFHO2dCQUMxQnhDLFlBQVksRUFBRSxFQUFFLDBEQUEwRDs7WUFDNUUsRUFBRSxPQUFPZ0MsS0FBSztnQkFDWkMsUUFBUTlCLEtBQUssQ0FBQzZCO2dCQUNkcEIsZ0JBQWdCb0IsZUFBZWlCLFFBQVFqQixJQUFJOEIsT0FBTyxHQUFHO1lBQ3ZELFNBQVU7Z0JBQ1JwRCxtQkFBbUI7WUFDckI7UUFDRjt5REFDQTtRQUFDZjtLQUFVO0lBR2IsT0FBTztRQUNMQTtRQUNBSTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBMEQ7UUFDQXFCO1FBQ0FDO1FBQ0FNO1FBQ0FsRjtRQUNBRTtRQUNBRTtRQUNBbUYsWUFBWXZIO0lBQ2Q7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2RhcnNoYW4vRG93bmxvYWRzL3BvaW50ZXItYWktbGFuZGluZy1wYWdlL2hvb2tzL3VzZUludGVydmlld1Nlc3Npb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcblxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiXG5cbnR5cGUgU3BlYWtlciA9IFwidXNlclwiIHwgXCJhc3Npc3RhbnRcIlxuXG5leHBvcnQgdHlwZSBJbnRlcnZpZXdNZXNzYWdlID0ge1xuICBpZDogc3RyaW5nXG4gIHNwZWFrZXI6IFNwZWFrZXJcbiAgdGV4dDogc3RyaW5nXG4gIHRpbWVzdGFtcDogbnVtYmVyXG59XG5cbnR5cGUgU3RhdHVzID0gXCJpZGxlXCIgfCBcInJlY29yZGluZ1wiIHwgXCJwcm9jZXNzaW5nXCIgfCBcImVycm9yXCJcblxuY29uc3QgYmFzZVVybCA9XG4gIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0lOVEVSVklFV19BUEk/LnJlcGxhY2UoL1xcLyQvLCBcIlwiKSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6ODAwMFwiXG5cbmNvbnN0IGI2NFRvQmxvYiA9IChiNjQ6IHN0cmluZywgdHlwZTogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGJ5dGVDaGFyYWN0ZXJzID0gYXRvYihiNjQpXG4gIGNvbnN0IGJ5dGVOdW1iZXJzID0gbmV3IEFycmF5KGJ5dGVDaGFyYWN0ZXJzLmxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlQ2hhcmFjdGVycy5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVOdW1iZXJzW2ldID0gYnl0ZUNoYXJhY3RlcnMuY2hhckNvZGVBdChpKVxuICB9XG4gIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVOdW1iZXJzKVxuICByZXR1cm4gbmV3IEJsb2IoW2J5dGVBcnJheV0sIHsgdHlwZSB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW50ZXJ2aWV3U2Vzc2lvbigpIHtcbiAgY29uc3QgW3Nlc3Npb25JZCwgc2V0U2Vzc2lvbklkXSA9IHVzZVN0YXRlKCgpID0+IGNyeXB0by5yYW5kb21VVUlEKCkpXG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGU8SW50ZXJ2aWV3TWVzc2FnZVtdPihbXSlcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlPFN0YXR1cz4oXCJpZGxlXCIpXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2lzUmVjb3JkaW5nLCBzZXRJc1JlY29yZGluZ10gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW3JlcGx5QXVkaW9VcmwsIHNldFJlcGx5QXVkaW9VcmxdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2lzU2F2aW5nQ29udGV4dCwgc2V0SXNTYXZpbmdDb250ZXh0XSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbY29udGV4dEVycm9yLCBzZXRDb250ZXh0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2NvbnRleHRTYXZlZEF0LCBzZXRDb250ZXh0U2F2ZWRBdF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKVxuXG4gIGNvbnN0IHJlY29yZGVyUmVmID0gdXNlUmVmPE1lZGlhUmVjb3JkZXIgfCBudWxsPihudWxsKVxuICBjb25zdCBjaHVua1JlZiA9IHVzZVJlZjxCbG9iW10+KFtdKVxuXG4gIHVzZUVmZmVjdChcbiAgICAoKSA9PiAoKSA9PiB7XG4gICAgICBpZiAocmVjb3JkZXJSZWYuY3VycmVudCAmJiByZWNvcmRlclJlZi5jdXJyZW50LnN0YXRlICE9PSBcImluYWN0aXZlXCIpIHtcbiAgICAgICAgcmVjb3JkZXJSZWYuY3VycmVudC5zdG9wKClcbiAgICAgIH1cbiAgICAgIGlmIChyZXBseUF1ZGlvVXJsKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwocmVwbHlBdWRpb1VybClcbiAgICAgIH1cbiAgICB9LFxuICAgIFtyZXBseUF1ZGlvVXJsXVxuICApXG5cbiAgY29uc3QgcGxheVJlcGx5QXVkaW8gPSB1c2VDYWxsYmFjaygoYmFzZTY0QXVkaW86IHN0cmluZykgPT4ge1xuICAgIGlmICghYmFzZTY0QXVkaW8pIHJldHVyblxuICAgIGNvbnN0IGJsb2IgPSBiNjRUb0Jsb2IoYmFzZTY0QXVkaW8sIFwiYXVkaW8vd2F2XCIpXG4gICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgIHNldFJlcGx5QXVkaW9VcmwoKHByZXYpID0+IHtcbiAgICAgIGlmIChwcmV2KSBVUkwucmV2b2tlT2JqZWN0VVJMKHByZXYpXG4gICAgICByZXR1cm4gdXJsXG4gICAgfSlcbiAgICBjb25zdCBwbGF5ZXIgPSBuZXcgQXVkaW8odXJsKVxuICAgIHBsYXllci5wbGF5KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwbGF5IHJlcGx5IGF1ZGlvOlwiLCBlcnIpXG4gICAgfSlcbiAgfSwgW10pXG5cbiAgY29uc3Qgc2VuZFR1cm4gPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoYXVkaW9CbG9iOiBCbG9iKSA9PiB7XG4gICAgICBzZXRTdGF0dXMoXCJwcm9jZXNzaW5nXCIpXG4gICAgICBzZXRFcnJvcihudWxsKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKFthdWRpb0Jsb2JdLCBgdHVybi0ke0RhdGUubm93KCl9LndlYm1gLCB7IHR5cGU6IGF1ZGlvQmxvYi50eXBlIH0pXG4gICAgICAgIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICAgICAgICBmb3JtLmFwcGVuZChcInNlc3Npb25faWRcIiwgc2Vzc2lvbklkKVxuICAgICAgICBmb3JtLmFwcGVuZChcImF1ZGlvXCIsIGZpbGUpXG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVXJsfS9pbnRlcnZpZXcvdHVybmAsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGJvZHk6IGZvcm0sXG4gICAgICAgIH0pXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhY2tlbmQgZXJyb3IgKCR7cmVzcG9uc2Uuc3RhdHVzfSlgKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IHBheWxvYWQudHJhbnNjcmlwdD8udHJpbSgpXG4gICAgICAgIGNvbnN0IHJlcGx5ID0gcGF5bG9hZC5yZXBseVRleHQ/LnRyaW0oKVxuXG4gICAgICAgIHNldE1lc3NhZ2VzKChwcmV2KSA9PiBbXG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICB0cmFuc2NyaXB0XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBpZDogYCR7RGF0ZS5ub3coKX0tdXNlcmAsXG4gICAgICAgICAgICAgICAgc3BlYWtlcjogXCJ1c2VyXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogdHJhbnNjcmlwdCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICByZXBseVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgaWQ6IGAke0RhdGUubm93KCl9LWFzc2lzdGFudGAsXG4gICAgICAgICAgICAgICAgc3BlYWtlcjogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiByZXBseSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgXS5maWx0ZXIoQm9vbGVhbikgYXMgSW50ZXJ2aWV3TWVzc2FnZVtdKVxuXG4gICAgICAgIGlmIChwYXlsb2FkLnJlcGx5QXVkaW8pIHtcbiAgICAgICAgICBwbGF5UmVwbHlBdWRpbyhwYXlsb2FkLnJlcGx5QXVkaW8pXG4gICAgICAgIH1cbiAgICAgICAgc2V0U3RhdHVzKFwiaWRsZVwiKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCIpXG4gICAgICAgIHNldFN0YXR1cyhcImVycm9yXCIpXG4gICAgICB9XG4gICAgfSxcbiAgICBbc2Vzc2lvbklkLCBwbGF5UmVwbHlBdWRpb11cbiAgKVxuXG4gIGNvbnN0IHN0YXJ0UmVjb3JkaW5nID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cbiAgICBpZiAoaXNSZWNvcmRpbmcpIHJldHVyblxuICAgIHNldEVycm9yKG51bGwpXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRydWUgfSlcbiAgICAgIGNvbnN0IG1pbWVUeXBlID0gTWVkaWFSZWNvcmRlci5pc1R5cGVTdXBwb3J0ZWQoXCJhdWRpby93ZWJtO2NvZGVjcz1vcHVzXCIpXG4gICAgICAgID8gXCJhdWRpby93ZWJtO2NvZGVjcz1vcHVzXCJcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgIGNvbnN0IHJlY29yZGVyID0gbmV3IE1lZGlhUmVjb3JkZXIoc3RyZWFtLCBtaW1lVHlwZSA/IHsgbWltZVR5cGUgfSA6IHVuZGVmaW5lZClcbiAgICAgIHJlY29yZGVyUmVmLmN1cnJlbnQgPSByZWNvcmRlclxuICAgICAgY2h1bmtSZWYuY3VycmVudCA9IFtdXG5cbiAgICAgIHJlY29yZGVyLm9uZGF0YWF2YWlsYWJsZSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnNpemUgPiAwKSB7XG4gICAgICAgICAgY2h1bmtSZWYuY3VycmVudC5wdXNoKGV2ZW50LmRhdGEpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVjb3JkZXIub25zdG9wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHRyYWNrLnN0b3AoKSlcbiAgICAgICAgY29uc3QgYXVkaW9CbG9iID0gbmV3IEJsb2IoY2h1bmtSZWYuY3VycmVudCwge1xuICAgICAgICAgIHR5cGU6IG1pbWVUeXBlIHx8IFwiYXVkaW8vd2VibVwiLFxuICAgICAgICB9KVxuICAgICAgICBjaHVua1JlZi5jdXJyZW50ID0gW11cbiAgICAgICAgc2V0SXNSZWNvcmRpbmcoZmFsc2UpXG4gICAgICAgIGlmIChhdWRpb0Jsb2Iuc2l6ZSA+IDApIHtcbiAgICAgICAgICBhd2FpdCBzZW5kVHVybihhdWRpb0Jsb2IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0U3RhdHVzKFwiaWRsZVwiKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlY29yZGVyLnN0YXJ0KClcbiAgICAgIHNldElzUmVjb3JkaW5nKHRydWUpXG4gICAgICBzZXRTdGF0dXMoXCJyZWNvcmRpbmdcIilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgc2V0RXJyb3IoXCJVbmFibGUgdG8gYWNjZXNzIG1pY3JvcGhvbmVcIilcbiAgICAgIHNldFN0YXR1cyhcImVycm9yXCIpXG4gICAgfVxuICB9LCBbaXNSZWNvcmRpbmcsIHNlbmRUdXJuXSlcblxuICBjb25zdCBzdG9wUmVjb3JkaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChyZWNvcmRlclJlZi5jdXJyZW50ICYmIHJlY29yZGVyUmVmLmN1cnJlbnQuc3RhdGUgPT09IFwicmVjb3JkaW5nXCIpIHtcbiAgICAgIHJlY29yZGVyUmVmLmN1cnJlbnQuc3RvcCgpXG4gICAgfVxuICB9LCBbXSlcblxuICBjb25zdCByZXNldFNlc3Npb24gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZldGNoKGAke2Jhc2VVcmx9L2ludGVydmlldy9yZXNldGAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHNlc3Npb25faWQ6IHNlc3Npb25JZCB9KSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gcmVzZXQgc2VydmVyIHNlc3Npb25cIiwgZXJyKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRTZXNzaW9uSWQoY3J5cHRvLnJhbmRvbVVVSUQoKSlcbiAgICAgIHNldE1lc3NhZ2VzKFtdKVxuICAgICAgc2V0RXJyb3IobnVsbClcbiAgICAgIHNldFN0YXR1cyhcImlkbGVcIilcbiAgICAgIHNldENvbnRleHRTYXZlZEF0KG51bGwpXG4gICAgICBzZXRDb250ZXh0RXJyb3IobnVsbClcbiAgICB9XG4gIH0sIFtzZXNzaW9uSWRdKVxuXG4gIGNvbnN0IHVwZGF0ZUNvbnRleHQgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoeyByZXN1bWVUZXh0LCBqb2JEZXNjcmlwdGlvbiB9OiB7IHJlc3VtZVRleHQ6IHN0cmluZzsgam9iRGVzY3JpcHRpb246IHN0cmluZyB9KSA9PiB7XG4gICAgICBzZXRJc1NhdmluZ0NvbnRleHQodHJ1ZSlcbiAgICAgIHNldENvbnRleHRFcnJvcihudWxsKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVXJsfS9pbnRlcnZpZXcvY29udGV4dGAsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBzZXNzaW9uX2lkOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICByZXN1bWVfdGV4dDogcmVzdW1lVGV4dCxcbiAgICAgICAgICAgIGpvYl9kZXNjcmlwdGlvbjogam9iRGVzY3JpcHRpb24sXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFja2VuZCBlcnJvciAoJHtyZXNwb25zZS5zdGF0dXN9KWApXG4gICAgICAgIH1cblxuICAgICAgICBzZXRDb250ZXh0U2F2ZWRBdChEYXRlLm5vdygpKVxuICAgICAgICBzZXRNZXNzYWdlcyhbXSkgLy8gQ2xlYXIgbG9jYWwgdHJhbnNjcmlwdCB0byByZWZsZWN0IHRoZSByZWZyZXNoZWQgY29udGV4dFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICBzZXRDb250ZXh0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiVW5hYmxlIHRvIHNhdmUgY29udGV4dFwiKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTYXZpbmdDb250ZXh0KGZhbHNlKVxuICAgICAgfVxuICAgIH0sXG4gICAgW3Nlc3Npb25JZF1cbiAgKVxuXG4gIHJldHVybiB7XG4gICAgc2Vzc2lvbklkLFxuICAgIG1lc3NhZ2VzLFxuICAgIHN0YXR1cyxcbiAgICBlcnJvcixcbiAgICBpc1JlY29yZGluZyxcbiAgICBzdGFydFJlY29yZGluZyxcbiAgICBzdG9wUmVjb3JkaW5nLFxuICAgIHJlc2V0U2Vzc2lvbixcbiAgICB1cGRhdGVDb250ZXh0LFxuICAgIGlzU2F2aW5nQ29udGV4dCxcbiAgICBjb250ZXh0RXJyb3IsXG4gICAgY29udGV4dFNhdmVkQXQsXG4gICAgYmFja2VuZFVybDogYmFzZVVybCxcbiAgfVxufVxuXG4iXSwibmFtZXMiOlsicHJvY2VzcyIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJiYXNlVXJsIiwiZW52IiwiTkVYVF9QVUJMSUNfSU5URVJWSUVXX0FQSSIsInJlcGxhY2UiLCJiNjRUb0Jsb2IiLCJiNjQiLCJ0eXBlIiwiYnl0ZUNoYXJhY3RlcnMiLCJhdG9iIiwiYnl0ZU51bWJlcnMiLCJBcnJheSIsImxlbmd0aCIsImkiLCJjaGFyQ29kZUF0IiwiYnl0ZUFycmF5IiwiVWludDhBcnJheSIsIkJsb2IiLCJ1c2VJbnRlcnZpZXdTZXNzaW9uIiwic2Vzc2lvbklkIiwic2V0U2Vzc2lvbklkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsIm1lc3NhZ2VzIiwic2V0TWVzc2FnZXMiLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJlcnJvciIsInNldEVycm9yIiwiaXNSZWNvcmRpbmciLCJzZXRJc1JlY29yZGluZyIsInJlcGx5QXVkaW9VcmwiLCJzZXRSZXBseUF1ZGlvVXJsIiwiaXNTYXZpbmdDb250ZXh0Iiwic2V0SXNTYXZpbmdDb250ZXh0IiwiY29udGV4dEVycm9yIiwic2V0Q29udGV4dEVycm9yIiwiY29udGV4dFNhdmVkQXQiLCJzZXRDb250ZXh0U2F2ZWRBdCIsInJlY29yZGVyUmVmIiwiY2h1bmtSZWYiLCJjdXJyZW50Iiwic3RhdGUiLCJzdG9wIiwiVVJMIiwicmV2b2tlT2JqZWN0VVJMIiwicGxheVJlcGx5QXVkaW8iLCJiYXNlNjRBdWRpbyIsImJsb2IiLCJ1cmwiLCJjcmVhdGVPYmplY3RVUkwiLCJwcmV2IiwicGxheWVyIiwiQXVkaW8iLCJwbGF5IiwiY2F0Y2giLCJlcnIiLCJjb25zb2xlIiwic2VuZFR1cm4iLCJhdWRpb0Jsb2IiLCJwYXlsb2FkIiwiZmlsZSIsIkZpbGUiLCJEYXRlIiwibm93IiwiZm9ybSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJvayIsIkVycm9yIiwianNvbiIsInRyYW5zY3JpcHQiLCJ0cmltIiwicmVwbHkiLCJyZXBseVRleHQiLCJpZCIsInNwZWFrZXIiLCJ0ZXh0IiwidGltZXN0YW1wIiwiZmlsdGVyIiwiQm9vbGVhbiIsInJlcGx5QXVkaW8iLCJtZXNzYWdlIiwic3RhcnRSZWNvcmRpbmciLCJzdHJlYW0iLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJhdWRpbyIsIm1pbWVUeXBlIiwiTWVkaWFSZWNvcmRlciIsImlzVHlwZVN1cHBvcnRlZCIsInVuZGVmaW5lZCIsInJlY29yZGVyIiwib25kYXRhYXZhaWxhYmxlIiwiZXZlbnQiLCJkYXRhIiwic2l6ZSIsInB1c2giLCJvbnN0b3AiLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidHJhY2siLCJzdGFydCIsInN0b3BSZWNvcmRpbmciLCJyZXNldFNlc3Npb24iLCJoZWFkZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsInNlc3Npb25faWQiLCJ3YXJuIiwidXBkYXRlQ29udGV4dCIsInJlc3VtZVRleHQiLCJqb2JEZXNjcmlwdGlvbiIsInJlc3VtZV90ZXh0Iiwiam9iX2Rlc2NyaXB0aW9uIiwiYmFja2VuZFVybCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useInterviewSession.ts\n"));

/***/ })

});